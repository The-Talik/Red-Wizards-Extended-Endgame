using Mono.Cecil;
using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.Serialization;

namespace RWMM.DTOGen
{
	internal static class DtoEmitter
	{
		// Global set so nested DTO types (_ShipBonus, etc.) are only emitted once
		private static readonly HashSet<string> emittedTypes = new HashSet<string>(StringComparer.Ordinal);

		public static string EmitDto(TypeDefinition source_type, string dto_namespace, string dto_name)
		{
			if (source_type == null) throw new ArgumentNullException(nameof(source_type));
			if (dto_namespace == null) throw new ArgumentNullException(nameof(dto_namespace));
			if (dto_name == null) throw new ArgumentNullException(nameof(dto_name));

			var sb = new StringBuilder(32 * 1024);

			sb.AppendLine("// <auto-generated />");
			sb.AppendLine("using System;");
			sb.AppendLine("using System.Collections.Generic;");
			sb.AppendLine("using System.Runtime.Serialization;");
			sb.AppendLine();
			sb.AppendLine("namespace " + dto_namespace);
			sb.AppendLine("{");

			EmitType(source_type, dto_name, sb);

			sb.AppendLine("}");

			return sb.ToString();
		}

		private static void EmitType(TypeDefinition type, string dto_name, StringBuilder sb)
		{
			if (type == null)
				return;

			// Only generate the class body once per source type
			if (!emittedTypes.Add(type.FullName))
				return;

			if (ShouldSkipType(type))
				return;

			sb.AppendLine("\t[DataContract]");
			sb.AppendLine("\tpublic class " + dto_name);
			sb.AppendLine("\t{");

			var used_names = new HashSet<string>(StringComparer.Ordinal);

			// Only public instance fields – properties are ignored on purpose
			foreach (var f in type.Fields)
			{
				if (!f.IsPublic || f.IsStatic)
					continue;

				if (f.IsInitOnly)
					continue;

				if (f.IsNotSerialized)
					continue;

				var member_name = f.Name;
				if (used_names.Contains(member_name))
					continue;

				string cs_type;
				if (!TryMapFieldType(f.FieldType, sb, out cs_type))
					continue;

				used_names.Add(member_name);
				var safe_name = ToSafeName(member_name);

				// All fields optional for JSON: IsRequired = false, EmitDefaultValue = false
				sb.AppendLine("\t\t[DataMember(IsRequired = false, EmitDefaultValue = false)]");
				sb.AppendLine("\t\tpublic " + cs_type + " " + safe_name + ";");
			}

			sb.AppendLine("\t}");
			sb.AppendLine();
		}

		private static bool TryMapFieldType(TypeReference type, StringBuilder sb, out string cs_type)
		{
			cs_type = null;
			if (type == null) return false;

			// ByRef<T> → T
			if (type is ByReferenceType br)
			{
				type = br.ElementType;
			}

			// Arrays
			if (type.IsArray)
			{
				var array_type = (ArrayType)type;
				string elem_type;
				if (!TryMapFieldType(array_type.ElementType, sb, out elem_type))
					return false;

				cs_type = elem_type + "[]";
				return true;
			}

			// Generic types (handle List<T>, skip Dictionary<,>)
			if (type.IsGenericInstance)
			{
				var gi = (GenericInstanceType)type;
				var generic_def = gi.ElementType;

				// List<T>
				if (generic_def.Namespace == "System.Collections.Generic" &&
						generic_def.Name.StartsWith("List`", StringComparison.Ordinal))
				{
					if (gi.GenericArguments.Count != 1)
						return false;

					string elem_type;
					if (!TryMapFieldType(gi.GenericArguments[0], sb, out elem_type))
						return false;

					cs_type = "List<" + elem_type + ">";
					return true;
				}

				// Dictionary<,> – skip for now
				if (generic_def.Namespace == "System.Collections.Generic" &&
						generic_def.Name.StartsWith("Dictionary`", StringComparison.Ordinal))
				{
					return false;
				}
			}

			// Resolve to TypeDefinition when possible
			var def = type.Resolve();

			// Simple / primitive / string / DateTime / Guid
			if (IsSimple(type, def))
			{
				cs_type = GetSimpleTypeName(type, def);
				return true;
			}

			// Enums → int to keep DTOs independent of game enums
			if (def != null && def.IsEnum)
			{
				cs_type = "int";
				return true;
			}

			// Unity value types (Vector2, etc.) – keep as Unity types
			if (IsUnityValueType(def))
			{
				cs_type = "global::" + def.FullName;
				return true;
			}

			// Unity reference types (Sprite, Transform, GameObject, etc.) – skip entirely
			if (IsUnityReferenceType(def))
			{
				return false;
			}

			// Skip obvious System.* types we don't want to DTO-ize
			if (IsSystemType(def))
			{
				return false;
			}

			// Complex nested game/data type – emit DTO recursively
			EmitType(def, GetDtoName(def), sb);
			cs_type = GetDtoName(def);
			return true;
		}

		private static bool ShouldSkipType(TypeDefinition type)
		{
			if (type == null) return true;

			// Never emit DTOs for obvious system types
			if (IsSystemType(type))
				return true;

			// Root Unity reference types are not DTO material either
			if (IsUnityReferenceType(type))
				return true;

			return false;
		}

		private static bool IsSystemType(TypeDefinition def)
		{
			if (def == null) return false;
			var ns = def.Namespace;
			if (string.IsNullOrEmpty(ns)) return false;

			return ns == "System" || ns.StartsWith("System.", StringComparison.Ordinal);
		}

		private static bool IsUnityReferenceType(TypeDefinition def)
		{
			if (def == null) return false;
			var ns = def.Namespace;
			if (ns != "UnityEngine") return false;

			// Class types in UnityEngine namespace (Sprite, Transform, GameObject, etc.)
			return def.IsClass && !def.IsValueType;
		}

		private static bool IsUnityValueType(TypeDefinition def)
		{
			if (def == null) return false;
			var ns = def.Namespace;
			return ns == "UnityEngine" && def.IsValueType;
		}

		private static bool IsSimple(TypeReference type, TypeDefinition def)
		{
			// primitive types via definition
			if (def != null && def.IsPrimitive)
				return true;

			var full_name = type.FullName;
			switch (full_name)
			{
				case "System.String":
				case "System.Decimal":
				case "System.DateTime":
				case "System.Guid":
					return true;
			}

			return false;
		}

		private static string GetSimpleTypeName(TypeReference type, TypeDefinition def)
		{
			if (def != null && def.IsPrimitive)
			{
				switch (def.FullName)
				{
					case "System.Boolean": return "bool";
					case "System.Byte": return "byte";
					case "System.SByte": return "sbyte";
					case "System.Int16": return "short";
					case "System.UInt16": return "ushort";
					case "System.Int32": return "int";
					case "System.UInt32": return "uint";
					case "System.Int64": return "long";
					case "System.UInt64": return "ulong";
					case "System.Single": return "float";
					case "System.Double": return "double";
					case "System.Char": return "char";
				}
			}

			switch (type.FullName)
			{
				case "System.String": return "string";
				case "System.Decimal": return "decimal";
				case "System.DateTime": return "DateTime";
				case "System.Guid": return "Guid";
			}

			return type.Name;
		}

		private static string GetDtoName(TypeDefinition type)
		{
			var name = type.Name;
			var tick = name.IndexOf('`');
			if (tick >= 0)
				name = name.Substring(0, tick);

			return "_" + name;
		}

		private static string ToSafeName(string name)
		{
			if (string.IsNullOrEmpty(name))
				return name;

			// Prefix @ for C# keywords that might show up as field names
			switch (name)
			{
				case "class":
				case "namespace":
				case "event":
				case "string":
				case "object":
				case "null":
				case "ref":
				case "out":
				case "in":
				case "base":
				case "params":
				case "public":
				case "private":
				case "protected":
				case "internal":
				case "new":
				case "virtual":
				case "override":
				case "readonly":
				case "volatile":
				case "operator":
				case "this":
				case "default":
				case "unchecked":
				case "checked":
				case "fixed":
				case "stackalloc":
				case "async":
				case "await":
				case "var":
					return "@" + name;
			}

			return name;
		}
	}
}
